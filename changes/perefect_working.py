# ! this even store the stats that is generated by the ML
import tkinter as tk
from tkinter import ttk, messagebox
import cv2
from PIL import Image, ImageTk
import mediapipe as mp
from deepface import DeepFace
import numpy as np
from collections import defaultdict, Counter
import threading
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Global stats dictionary, thread-safe with a lock
stats = {
    'persons': defaultdict(list)  # name -> list of analysis dicts
}
stats_lock = threading.Lock()


class FaceAnalysisApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Face Analysis System")
        self.root.geometry("1280x720")
        self.root.configure(bg='#2c3e50')

        # Frame to hold the live video
        self.video_frame = ttk.LabelFrame(root, text="Live Camera Feed", width=800, height=600)
        self.video_frame.pack(side=tk.LEFT, padx=10, pady=10)

        # Frame for additional information and statistics
        self.info_frame = ttk.Frame(root, width=400, height=600)
        self.info_frame.pack(side=tk.RIGHT, padx=10, pady=10, fill=tk.BOTH)

        self.cap = cv2.VideoCapture(0)
        self.video_label = ttk.Label(self.video_frame)
        self.video_label.pack()

        # MediaPipe Face Detection
        self.mp_face_detection = mp.solutions.face_detection
        self.face_detection = self.mp_face_detection.FaceDetection(min_detection_confidence=0.7)

        self.matched_face_label = ttk.Label(self.info_frame)
        self.matched_face_label.pack(pady=10)

        self.analysis_tree = ttk.Treeview(self.info_frame, columns=('Value'), show='headings', height=5)
        self.analysis_tree.heading('#0', text='Attribute')
        self.analysis_tree.heading('Value', text='Value')
        self.analysis_tree.column('#0', width=120)
        self.analysis_tree.column('Value', width=200)
        self.analysis_tree.tag_configure('header', background='#3498db', foreground='white')
        self.analysis_tree.pack(fill=tk.BOTH, expand=True)

        self.stats_button = ttk.Button(self.info_frame, text="Show Stats", command=self.show_stats_menu)
        self.stats_button.pack(pady=10)

        self.update_video()
        self.root.protocol("WM_DELETE_WINDOW", self.on_close)

    def update_video(self):
        ret, frame = self.cap.read()
        if ret:
            rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = self.face_detection.process(rgb_frame)

            analysis_results = {}

            if results.detections:
                for detection in results.detections:
                    bbox = detection.location_data.relative_bounding_box
                    ih, iw, _ = frame.shape
                    x = int(bbox.xmin * iw)
                    y = int(bbox.ymin * ih)
                    w = int(bbox.width * iw)
                    h = int(bbox.height * ih)

                    cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                    face_roi = frame[y:y + h, x:x + w]

                    try:
                        # Attempt to match the face and analyze attributes
                        dfs = DeepFace.find(
                            img_path=face_roi,
                            db_path="db",
                            enforce_detection=False,
                            silent=True
                        )

                        analysis = DeepFace.analyze(
                            img_path=face_roi,
                            actions=['age', 'gender', 'emotion'],
                            enforce_detection=False,
                            silent=True,
                            detector_backend='mtcnn'
                        )
                        if isinstance(analysis, list):
                            analysis = analysis[0]

                        # Normalize gender in case it is provided as dictionary probabilities
                        if isinstance(analysis['gender'], dict):
                            gender = max(analysis['gender'].items(), key=lambda x: x[1])[0]
                        else:
                            gender = analysis['gender']

                        emotion = max(analysis['emotion'].items(), key=lambda x: x[1])[0]

                        analysis_results = {
                            'Age': analysis['age'],
                            'Gender': gender,
                            'Emotion': emotion,
                            'Name': 'Unknown'
                        }

                        if dfs and not dfs[0].empty:
                            best_match = dfs[0].iloc[0]
                            name = best_match['identity'].split('/')[-1]
                            analysis_results['Name'] = name
                            self.update_matched_face(best_match['identity'])

                            with stats_lock:
                                stats['persons'][name].append({
                                    'age': analysis['age'],
                                    'gender': gender,
                                    'emotion': emotion
                                })

                    except Exception as e:
                        print(f"Analysis error: {e}")

            # Convert BGR frame to RGB and display using PIL
            img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img = Image.fromarray(img)
            imgtk = ImageTk.PhotoImage(image=img)
            self.video_label.imgtk = imgtk
            self.video_label.configure(image=imgtk)

            self.update_analysis_tree(analysis_results)

        self.root.after(10, self.update_video)

    def update_matched_face(self, path):
        try:
            img = Image.open(path)
            img.thumbnail((300, 300))
            photo = ImageTk.PhotoImage(img)
            self.matched_face_label.configure(image=photo)
            self.matched_face_label.image = photo
        except Exception as e:
            print(f"Image load error: {e}")

    def update_analysis_tree(self, results):
        self.analysis_tree.delete(*self.analysis_tree.get_children())
        for key, value in results.items():
            self.analysis_tree.insert('', 'end', text=key, values=(value,))
            self.analysis_tree.item(
                self.analysis_tree.get_children()[-1],
                tags=('header',) if key == 'Name' else ()
            )

    def show_stats_menu(self):
        stats_window = tk.Toplevel()
        stats_window.title("Select Person")
        stats_window.geometry("300x400")

        with stats_lock:
            persons = list(stats['persons'].keys())

        for name in persons:
            btn = ttk.Button(stats_window, text=name, command=lambda n=name: self.show_person_stats(n))
            btn.pack(pady=5)

        # Add Export All button
        export_all_btn = ttk.Button(stats_window, text="Export All to Excel", command=self.export_all_data)
        export_all_btn.pack(pady=10)

    def show_person_stats(self, name):
        top = tk.Toplevel()
        top.title(f"{name} - Statistics")
        top.geometry("600x500")

        with stats_lock:
            data = stats['persons'].get(name, [])

        if not data:
            tk.Label(top, text="No data available.").pack()
            return

        try:
            # Calculate average age, most common gender and emotion over the data points
            ages = [entry['age'] for entry in data if isinstance(entry, dict) and 'age' in entry]
            genders = [entry['gender'] for entry in data if isinstance(entry, dict) and 'gender' in entry]
            emotions = [entry['emotion'] for entry in data if isinstance(entry, dict) and 'emotion' in entry]

            avg_age = sum(ages) / len(ages)
            gender_label = Counter(genders).most_common(1)[0][0]
            emotion_label = Counter(emotions).most_common(1)[0][0]

            # Display textual statistics
            tk.Label(top, text=f"Average Age: {avg_age:.2f}").pack(pady=5)
            tk.Label(top, text=f"Most Common Gender: {gender_label}").pack(pady=5)
            tk.Label(top, text=f"Most Common Emotion: {emotion_label}").pack(pady=5)

            # Build a visualization for emotion distribution
            emotion_counts = Counter(emotions)
            labels = list(emotion_counts.keys())
            sizes = list(emotion_counts.values())

            # Create a matplotlib figure to generate a pie chart.
            fig = plt.Figure(figsize=(4, 3), dpi=100)
            ax = fig.add_subplot(111)
            ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
            ax.set_title("Emotion Distribution")
            ax.axis('equal')

            # Embed the matplotlib figure into Tkinter.
            canvas = FigureCanvasTkAgg(fig, master=top)
            canvas.draw()
            canvas.get_tk_widget().pack(pady=10, fill=tk.BOTH, expand=True)

        except Exception as e:
            tk.Label(top, text=f"Error processing data: {e}").pack()

        # Add Export button for individual
        export_btn = ttk.Button(top, text="Export to Excel", command=lambda: self.export_person_data(name))
        export_btn.pack(pady=10)

    def export_person_data(self, name):
        with stats_lock:
            data = stats['persons'].get(name, [])
        
        if not data:
            messagebox.showwarning("No Data", f"No data available for {name}.")
            return
        
        # Convert to DataFrame and save
        try:
            df = pd.DataFrame(data)
            df['Name'] = name
            df = df[['Name', 'age', 'gender', 'emotion']]
            filename = f"{name}_stats.xlsx"
            df.to_excel(filename, index=False)
            messagebox.showinfo("Success", f"Data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def export_all_data(self):
        with stats_lock:
            all_data = []
            for name, entries in stats['persons'].items():
                for entry in entries:
                    entry_copy = entry.copy()
                    entry_copy['Name'] = name
                    all_data.append(entry_copy)
        
        if not all_data:
            messagebox.showwarning("No Data", "No data available to export.")
            return
        
        try:
            df = pd.DataFrame(all_data)
            df = df[['Name', 'age', 'gender', 'emotion']]
            filename = "all_persons_stats.xlsx"
            df.to_excel(filename, index=False)
            messagebox.showinfo("Success", f"All data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def on_close(self):
        self.cap.release()
        self.root.destroy()


if __name__ == "__main__":
    root = tk.Tk()
    app = FaceAnalysisApp(root)
    root.mainloop()